<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Kıble Yönü Bulma — Sesli & Görsel Pusula</title>
  <meta name="description" content="Konum ve pusula ile anlık kıble bulma. Sesli yönlendirme, harita desteği, mobil uyumlu." />
  <!-- Leaflet CSS (harita için) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-sA+e2s4a6b0h3gGgk9gY8nQq8QbI6Y7p0v+g1hS3U/c=" crossorigin="" />

  <style>
    /* -------------------- Temel Stil -------------------- */
    :root{
      --bg: #071026;
      --card: linear-gradient(180deg,#0d1530 0%, #0b1224 100%);
      --muted: #9fb1d1;
      --text: #eaf4ff;
      --accent: #28e1c1;
      --accent-2: #7c5cff;
      --danger: #ff5864;
      --ok: #2ecc71;
      --glass: rgba(255,255,255,0.04);
      --maxw: 980px;
    }
    [data-theme="light"]{
      --bg: #f6f8fb; --card: linear-gradient(180deg,#ffffff,#f7fbff);
      --muted:#5d6b7f; --text:#07142a; --accent:#087c6d; --accent-2:#5b3be6; --glass: rgba(2,6,23,0.03);
    }

    html,body{height:100%; margin:0; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:linear-gradient(180deg,var(--bg), #041026 160%); color:var(--text); -webkit-font-smoothing:antialiased;}
    .container{max-width:var(--maxw); margin:14px auto; padding:16px;}
    header{display:flex; justify-content:space-between; align-items:center; gap:12px}
    .brand{display:flex; align-items:center; gap:12px}
    .logo{width:48px; height:48px; border-radius:10px; display:grid; place-items:center; font-weight:900; background:linear-gradient(135deg,var(--accent),var(--accent-2)); color:#041026}
    .title{font-weight:800; font-size:18px}
    .subtitle{font-size:12px; color:var(--muted)}
    .controls{display:flex; gap:8px; align-items:center}

    button.btn{border:0; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:700}
    button.primary{background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#041026; box-shadow:0 10px 30px rgba(2,6,23,0.45)}
    button.ghost{background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--text)}
    button.small{padding:8px 10px; font-size:13px}

    main.card{margin-top:14px; background:var(--card); border-radius:16px; padding:18px; box-shadow:0 30px 80px rgba(2,6,23,0.5)}
    .top{display:flex; justify-content:space-between; gap:12px; align-items:center}
    .left{display:flex; flex-direction:column; gap:6px}
    .center{display:flex; flex-direction:column; align-items:center; gap:12px; margin-top:14px}

    /* Pusula çerçevesi */
    .compass-wrap{width:92vw; max-width:640px; aspect-ratio:1/1; border-radius:999px; display:grid; place-items:center; position:relative; background:radial-gradient(60% 60% at 35% 30%, rgba(255,255,255,0.02), transparent 40%); overflow:hidden; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.03)}
    svg.dial{width:86%; height:86%;}
    /* needle and kaaba marker */
    .needle{position:absolute; width:6px; height:48%; left:50%; top:6%; transform-origin:50% 92%; background:linear-gradient(180deg,var(--danger),transparent); border-radius:6px; box-shadow:0 8px 20px rgba(0,0,0,0.6)}
    .needle .cap{position:absolute; left:50%; top:-10px; width:24px; height:24px; background:var(--accent); border-radius:50%; transform:translateX(-50%); box-shadow:0 6px 14px rgba(0,0,0,.5)}
    .kaaba-marker{position:absolute; width:72px; height:48px; right:26%; top:36%; transform-origin:50% 50%; display:grid; place-items:center}
    .kaaba-marker .box{width:70%; height:70%; background:#05060a; border-radius:6px; box-shadow:inset 0 -6px 0 rgba(255,255,255,0.02)}
    .big-angle{font-size:64px; font-weight:900; letter-spacing:-2px}
    .instruction{font-weight:900; padding:10px 16px; border-radius:999px; font-size:18px}

    .dir-left{background:linear-gradient(90deg,#ff6b6b,#ff9a9a); color:#fff}
    .dir-right{background:linear-gradient(90deg,#13c6a6,#26e1c1); color:#042126}
    .dir-ok{background:linear-gradient(90deg,#22c55e,#86efac); color:#05220f}

    .readouts{display:grid; grid-template-columns:repeat(2,1fr); gap:10px; margin-top:12px}
    .stat{background:var(--glass); padding:12px; border-radius:12px}
    .stat .label{font-size:12px; color:var(--muted)}
    .stat .value{font-weight:800; font-size:18px}

    /* map area */
    #map{height:240px; border-radius:12px; margin-top:14px; overflow:hidden; box-shadow:0 18px 60px rgba(2,6,23,0.45)}

    footer{margin-top:12px; text-align:center; color:var(--muted); font-size:13px}

    /* responsive */
    @media (max-width:720px){
      .big-angle{font-size:44px}
      .compass-wrap{width:92vw}
      .readouts{grid-template-columns:1fr}
      .kaaba-marker{width:56px;height:40px; right:18%; top:38%}
      .needle{width:5px}
    }

    /* focus accessibility */
    button:focus{outline:3px solid rgba(38,226,193,0.12); outline-offset:3px}
  </style>
</head>
<body>
  <div class="container" id="app">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden>Q</div>
        <div>
          <div class="title">Kıble Yönü Bulma</div>
          <div class="subtitle">Sesli + Görsel Pusula • Harita ile destekli</div>
        </div>
      </div>
      <div class="controls">
        <button id="btnStart" class="btn primary">Başlat</button>
        <button id="btnCal" class="btn ghost small">Kalibre</button>
        <button id="btnMode" class="btn small">Manuel: Kapalı</button>
      </div>
    </header>

    <main class="card" role="main">
      <div class="top">
        <div class="left">
          <div style="font-size:13px; color:var(--muted)">Kâbe koordinatları (sabit):</div>
          <div style="font-weight:800">21°25'21.0&quot; N — 39°49'34.2&quot; E (21.422500, 39.826167)</div>
          <div style="font-size:13px; color:var(--muted); margin-top:6px">Uyarı: En doğru sonuç için dışarıya çıkın ve manyetik alanlardan uzak durun.</div>
        </div>
        <div style="text-align:right">
          <div style="font-size:12px; color:var(--muted)">Mesafe Mescid-i Haram</div>
          <div id="distLabel" style="font-weight:900; font-size:18px">— km</div>
        </div>
      </div>

      <!-- Compass / Central area -->
      <div class="center">
        <div class="compass-wrap" id="compassWrap" aria-hidden="false">
          <!-- SVG dial drawn by JS (ticks, labels) -->
          <svg class="dial" id="svgDial" viewBox="0 0 200 200" role="img" aria-label="Pusula"></svg>

          <div class="needle" id="needle" style="transform:rotate(0deg)">
            <div class="cap"></div>
          </div>

          <!-- Kâbe görseli (döndürme ile hedeflenen açıya göre döndürülür) -->
          <div class="kaaba-marker" id="kaabaMarker" aria-hidden="true" title="Kâbe hedefi">
            <div class="box" style="width:70%; height:70%"></div>
          </div>
        </div>

        <div style="display:flex; flex-direction:column; align-items:center; gap:8px;">
          <div class="big-angle" id="bigAngle">—°</div>
          <div id="instruction" class="instruction dir-left">Başlamak için &quot;Başlat&quot; a dokunun</div>
        </div>

        <div class="readouts" style="width:100%; max-width:820px">
          <div class="stat">
            <div class="label">Cihaz Başlığı (Heading)</div>
            <div id="headingLabel" class="value">—°</div>
          </div>

          <div class="stat">
            <div class="label">Kıble Açısı (Kâbe'ye göre)</div>
            <div id="qiblaLabel" class="value">—°</div>
          </div>

          <div class="stat">
            <div class="label">Açı Farkı</div>
            <div id="deltaLabel" class="value">—°</div>
          </div>

          <div class="stat">
            <div class="label">GPS Doğruluğu</div>
            <div id="accLabel" class="value">— m</div>
          </div>
        </div>

        <div style="display:flex; gap:8px; margin-top:12px; flex-wrap:wrap;">
          <button id="btnVoiceToggle" class="btn small ghost">Sesli: Açık</button>
          <button id="btnCopyCoord" class="btn small ghost">Koordinatı Kopyala</button>
          <button id="btnStop" class="btn small">Durdur</button>
        </div>

        <!-- Map -->
        <div id="map" aria-label="Harita"></div>
      </div>
    </main>

    <footer>
      <div style="margin-top:10px">© <span id="yr"></span> Kıble Yönü Bulma — Mobil uyumlu. Test için canlı sunucu (https veya localhost) kullanın.</div>
    </footer>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-o8g9mYw4X6V8Kx7wZHqzQ0ym3wXkP6v2n2b9g2MQT0M=" crossorigin=""></script>

  <script>
  /*****************************************************************
   * KIBLE YÖNÜ BULMA - TEK SAYFA UYGULAMA
   *
   * Özellikler:
   *  - Geolocation (watchPosition)
   *  - DeviceOrientation (iOS için requestPermission)
   *  - Kâbe bearing hesaplama (verilen koordinata göre)
   *  - Sesli yönlendirme (Web Speech API)
   *  - Harita (Leaflet)
   *  - Manuel mod (masaüstü için sürükle/döndür)
   *
   * Notlar:
   *  - HTTPS / localhost gereklidir.
   *  - iOS Safari için DeviceOrientation izni Başlat tuşuna tıklanarak istenmelidir.
   *****************************************************************/

  (function(){
    // --------------- Sabitler ---------------
    // Kâbe koordinatları (kullanıcının verdiği DMS => decimal)
    const KAABA = { lat: 21.422500, lon: 39.826167 }; // 21°25'21.0" N , 39°49'34.2" E
    const EARTH_R = 6371000; // metre

    // Uyarı eşikleri
    const ANGLE_OK_THRESHOLD = 3.0;      // kaç derece içinde "tam" kabul edilir
    const ANGLE_NOTICE_STEP = 5.0;       // sesli uyarı için fark değişim adımı (derece)
    const GPS_ACC_WARN = 100;            // metre, > bu değerde GPS zayıf
    const VOICE_COOLDOWN_MS = 1200;      // sesli uyarı aralığı (ms)

    // DOM
    const btnStart = document.getElementById('btnStart');
    const btnCal = document.getElementById('btnCal');
    const btnMode = document.getElementById('btnMode');
    const btnVoiceToggle = document.getElementById('btnVoiceToggle');
    const btnCopy = document.getElementById('btnCopyCoord');
    const btnStop = document.getElementById('btnStop');

    const bigAngle = document.getElementById('bigAngle');
    const instruction = document.getElementById('instruction');
    const headingLabel = document.getElementById('headingLabel');
    const qiblaLabel = document.getElementById('qiblaLabel');
    const deltaLabel = document.getElementById('deltaLabel');
    const accLabel = document.getElementById('accLabel');
    const distLabel = document.getElementById('distLabel');
    const needle = document.getElementById('needle');
    const kaabaMarker = document.getElementById('kaabaMarker');
    const svgDial = document.getElementById('svgDial');
    const compassWrap = document.getElementById('compassWrap');

    document.getElementById('yr').textContent = new Date().getFullYear();

    // State
    let state = {
      pos: null,          // {lat, lon}
      acc: null,          // gps accuracy
      headingRaw: null,   // ham alpha / compass heading
      heading: null,      // süzülmüş heading 0..360 (0=kuzey)
      qibla: null,        // kıble açısı 0..360
      distance: null,     // metre
      watchId: null,
      haveCompass: false,
      manualMode: false,
      manualRotation: 0,
      voiceOn: true,
      lastSpokenAngle: null,
      lastVoiceAt: 0
    };

    // Speech synthesis (sesli yönerge)
    const synth = window.speechSynthesis;
    const voices = [];
    function getTTSVoice(){
      // Tercihen Türkçe ses; yoksa varsayılan
      const vlist = speechSynthesis.getVoices();
      if(!vlist || vlist.length===0) return null;
      const tr = vlist.find(v=>/turk|tr-/i.test(v.lang));
      if(tr) return tr;
      const en = vlist.find(v=>/en-/i.test(v.lang));
      if(en) return en;
      return vlist[0];
    }

    // Utility
    const toRad = d => d * Math.PI / 180;
    const toDeg = r => r * 180 / Math.PI;
    const norm360 = a => ( (a % 360) + 360 ) % 360;
    function shortestDelta(a,b){ // a->b minimal delta (-180..180)
      let d = norm360(b) - norm360(a);
      if(d > 180) d -= 360;
      if(d < -180) d += 360;
      return d;
    }

    // Bearing formula (from lat/lon to target)
    function bearingTo(lat1, lon1, lat2, lon2){
      const φ1 = toRad(lat1), φ2 = toRad(lat2);
      const Δλ = toRad(lon2 - lon1);
      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
      return norm360(toDeg(Math.atan2(y,x)));
    }

    // Distance Haversine (m)
    function distanceMeters(lat1, lon1, lat2, lon2){
      const φ1 = toRad(lat1), φ2 = toRad(lat2);
      const dφ = toRad(lat2 - lat1), dλ = toRad(lon2 - lon1);
      const a = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return EARTH_R * c;
    }

    // Simple circular EMA smoothing for heading
    function smoothHeading(prev, next, alpha=0.25){
      if(prev == null) return next;
      const d = shortestDelta(prev, next);
      return norm360(prev + d * alpha);
    }

    // ---------------- Map (Leaflet) ----------------
    let map, meMarker, kaabaMarkerMap, lineToKaaba;
    function initMap(){
      try {
        map = L.map('map', { zoomControl: false }).setView([KAABA.lat, KAABA.lon], 3);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        kaabaMarkerMap = L.marker([KAABA.lat, KAABA.lon], { title: "Kâbe", opacity: 0.9 }).addTo(map).bindPopup("Kâbe (Mescid-i Haram)");
        lineToKaaba = L.polyline([], { color: '#26e1c1', weight: 3, opacity: 0.9 }).addTo(map);
      } catch (e){
        console.warn('Harita başlatılamadı: ', e);
        document.getElementById('map').style.display = 'none';
      }
    }

    // Update map with user position
    function updateMapPosition(lat, lon){
      if(!map) return;
      if(!meMarker){
        meMarker = L.marker([lat,lon], { title: "Siz", opacity: 0.9 }).addTo(map).bindPopup("Sizin konumunuz");
      } else {
        meMarker.setLatLng([lat,lon]);
      }
      // draw line
      lineToKaaba.setLatLngs([[lat,lon], [KAABA.lat, KAABA.lon]]);
      // adjust view to include both points if zoomed out
      const bounds = L.latLngBounds([[lat,lon],[KAABA.lat, KAABA.lon]]);
      map.fitBounds(bounds.pad(0.35), { animate: true, duration: 0.6, maxZoom: 12 });
    }

    // ---------------- SVG Dial drawing ----------------
    function drawDial(){
      const ns = "http://www.w3.org/2000/svg";
      // clear
      while(svgDial.firstChild) svgDial.removeChild(svgDial.firstChild);

      const view = {w:200, h:200, cx:100, cy:100, rOut:92};
      svgDial.setAttribute('viewBox', `0 0 ${view.w} ${view.h}`);

      // outer ring
      const ring = document.createElementNS(ns, 'circle');
      ring.setAttribute('cx', view.cx); ring.setAttribute('cy', view.cy); ring.setAttribute('r', 92);
      ring.setAttribute('stroke', 'rgba(255,255,255,0.07)'); ring.setAttribute('fill', 'none'); ring.setAttribute('stroke-width', 1.6);
      svgDial.appendChild(ring);

      // ticks
      for(let i=0;i<360;i+=3){
        const rad = (i - 90) * Math.PI/180;
        const r1 = view.rOut;
        let len = 4, sw = 0.7;
        if(i % 30 === 0){ len = 8; sw = 1.4; }
        else if(i % 15 === 0){ len = 6; sw = 1.0; }
        const r2 = r1 - len;
        const x1 = view.cx + Math.cos(rad) * r1;
        const y1 = view.cy + Math.sin(rad) * r1;
        const x2 = view.cx + Math.cos(rad) * r2;
        const y2 = view.cy + Math.sin(rad) * r2;
        const line = document.createElementNS(ns, 'line');
        line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2);
        line.setAttribute('stroke', 'rgba(255,255,255,0.06)'); line.setAttribute('stroke-width', sw);
        svgDial.appendChild(line);
      }

      // cardinal labels N E S W
      const labels = [{t:'N',x:100,y:18},{t:'E',x:182,y:102},{t:'S',x:100,y:186},{t:'W',x:18,y:102}];
      labels.forEach(l=>{
        const t = document.createElementNS(ns, 'text');
        t.setAttribute('x', l.x); t.setAttribute('y', l.y); t.setAttribute('text-anchor','middle');
        t.setAttribute('fill', 'rgba(255,255,255,0.9)'); t.setAttribute('font-size', 12); t.setAttribute('font-weight', 900);
        t.textContent = l.t;
        svgDial.appendChild(t);
      });
    }

    // ---------------- UI updates ----------------
    function formatDeg(v, fixed=0){ return (isFinite(v)? v.toFixed(fixed) + '°' : '—'); }
    function formatDist(m){ if(!isFinite(m)) return '— km'; if(m<1000) return Math.round(m) + ' m'; return (m/1000).toFixed(1) + ' km'; }

    function refreshUI(){
      // labels
      headingLabel.textContent = state.heading != null ? Math.round(state.heading) + '°' : '—°';
      qiblaLabel.textContent = state.qibla != null ? Math.round(state.qibla) + '°' : '—°';
      accLabel.textContent = state.acc != null ? Math.round(state.acc) + ' m' : '— m';
      distLabel.textContent = state.distance != null ? formatDist(state.distance) : '— km';

      // angle display - bigAngle shows qibla if available
      bigAngle.textContent = (state.qibla!=null? Math.round(state.qibla) + '°' : '—°');

      // set needle rotation to device heading (needle points to north relative to device)
      const deviceAngle = state.manualMode ? (state.manualRotation || 0) : (state.heading || 0);
      needle.style.transform = `rotate(${deviceAngle}deg)`;

      // place kaaba marker visually rotated to qibla (rotate marker so it points to target)
      if(state.qibla != null){
        // rotate the kaaba marker to indicate the direction from top (0=north). We'll set transform rotate(qibla)
        kaabaMarker.style.transform = `rotate(${state.qibla}deg)`;
      }

      // compute delta
      if(state.qibla != null && (deviceAngle != null)){
        let d = shortestDelta(deviceAngle, state.qibla); // + => turn right
        deltaLabel.textContent = (d>0? '+':'' ) + d.toFixed(1) + '°';

        // instruction text and badge
        const absd = Math.abs(d);
        if(absd <= ANGLE_OK_THRESHOLD){
          instruction.textContent = 'Kıble bulundu ✅';
          instruction.className = 'instruction dir-ok';
        } else if(d > 0){
          instruction.textContent = Math.abs(d).toFixed(0) + '° sağa dönün';
          instruction.className = 'instruction dir-right';
        } else {
          instruction.textContent = Math.abs(d).toFixed(0) + '° sola dönün';
          instruction.className = 'instruction dir-left';
        }

        // voice guidance decision
        maybeSpeakAngle(d);
      } else {
        deltaLabel.textContent = '—°';
      }
    }

    // ---------------- Voice logic ----------------
    function speak(text){
      if(!state.voiceOn) return;
      if(!('speechSynthesis' in window)) return;
      const now = Date.now();
      // throttle if recently spoken
      if(now - state.lastVoiceAt < 600) return;
      state.lastVoiceAt = now;
      const utter = new SpeechSynthesisUtterance(text);
      const v = getTTSVoice();
      if(v) utter.voice = v;
      utter.pitch = 1.0; utter.rate = 1.0; utter.lang = utter.voice && utter.voice.lang ? utter.voice.lang : 'tr-TR';
      try {
        synth.cancel(); // stop previous
        synth.speak(utter);
      } catch (e){
        console.warn('TTS hatası', e);
      }
    }

    function maybeSpeakAngle(delta){
      // only speak when voice on and when delta changes meaningfully
      if(!state.voiceOn) return;
      const now = Date.now();
      if(now - state.lastVoiceAt < VOICE_COOLDOWN_MS) return;

      // If within OK threshold -> speak once
      if(Math.abs(delta) <= ANGLE_OK_THRESHOLD){
        // announce found
        if(state.lastSpokenAngle === null || Math.abs(state.lastSpokenAngle) > ANGLE_OK_THRESHOLD){
          speak('Kıble bulundu. Yönünüz doğru.');
          state.lastSpokenAngle = delta;
        }
        return;
      }

      // If delta changes more than step from lastSpokenAngle -> speak
      if(state.lastSpokenAngle === null || Math.abs(state.lastSpokenAngle - delta) >= ANGLE_NOTICE_STEP){
        const dir = delta > 0 ? 'sağa' : 'sola';
        const deg = Math.abs(Math.round(delta));
        speak(`${deg} derece ${dir} dönünüz`);
        state.lastSpokenAngle = delta;
      }
    }

    // ---------------- Permissions & sensors ----------------
    function startGeolocation(){
      if(!navigator.geolocation){
        alert('Tarayıcı konum API desteği yok.');
        return;
      }
      if(state.watchId) navigator.geolocation.clearWatch(state.watchId);
      state.watchId = navigator.geolocation.watchPosition(p=>{
        state.pos = { lat: p.coords.latitude, lon: p.coords.longitude };
        state.acc = p.coords.accuracy;
        // compute qibla and distance
        state.qibla = bearingTo(state.pos.lat, state.pos.lon, KAABA.lat, KAABA.lon);
        state.distance = distanceMeters(state.pos.lat, state.pos.lon, KAABA.lat, KAABA.lon);
        // update map
        updateMapPosition(state.pos.lat, state.pos.lon);
        // update UI
        refreshUI();
        // GPS accuracy warning if needed
        if(state.acc && state.acc > GPS_ACC_WARN){
          // show short hint
          // Use voice if on
          if(state.voiceOn) speak('GPS doğruluğu düşük. Açık alana çıkın ve tekrar deneyin.');
        }
      }, err=>{
        console.warn('Konum hatası', err);
        alert('Konum alınamadı: ' + (err && err.message ? err.message : 'Bilinmeyen hata.'));
      }, { enableHighAccuracy: true, maximumAge: 1000, timeout: 20000 });
    }

    function startCompass(){
      // iOS requires explicit permission call
      const DeviceOrientationEventExists = typeof DeviceOrientationEvent !== 'undefined';
      const iosReq = DeviceOrientationEventExists && typeof DeviceOrientationEvent.requestPermission === 'function';
      if(iosReq){
        // ask permission on user gesture
        DeviceOrientationEvent.requestPermission().then(function(resp){
          if(resp === 'granted'){
            attachDeviceOrientation();
          } else {
            alert('Pusula izni verilmedi. Manuel modda devam edebilirsiniz.');
            state.haveCompass = false;
            refreshUI();
          }
        }).catch(err=>{
          console.warn('iOS permission hata', err);
          alert('Pusula izni alınamadı. Tarayıcı izinlerini kontrol edin.');
        });
      } else {
        attachDeviceOrientation();
      }
    }

    function attachDeviceOrientation(){
      // Listen for deviceorientation events (absolute or alpha)
      function handler(ev){
        // many devices have webkitCompassHeading (iOS)
        let heading = null;
        if(typeof ev.webkitCompassHeading !== 'undefined' && ev.webkitCompassHeading !== null){
          heading = ev.webkitCompassHeading; // 0..360, 0=north
        } else if(ev.absolute === true && ev.alpha != null){
          // convert alpha to compass bearing
          heading = 360 - ev.alpha;
        } else if(ev.alpha != null){
          heading = 360 - ev.alpha;
        }
        if(heading != null && isFinite(heading)){
          state.haveCompass = true;
          state.headingRaw = norm360(heading);
          state.heading = smoothHeading(state.heading, state.headingRaw, 0.28);
          refreshUI();
        }
      }
      window.addEventListener('deviceorientationabsolute', handler, true);
      window.addEventListener('deviceorientation', handler, true);
      // If no events come, we will fallback to manual mode
      // Some desktop browsers won't fire these events
      setTimeout(()=>{
        if(!state.haveCompass){
          console.log('Cihaz pusula verisi gondermiyor veya izin yok. Manuel moda geçebilirsiniz.');
        }
      }, 2500);
    }

    // ---------------- Manual mode (drag to rotate) ----------------
    function enableManualDrag(){
      let dragging = false;
      let lastA = 0;
      function angleFromEvent(e){
        const rect = compassWrap.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const x = clientX - cx, y = clientY - cy;
        let ang = Math.atan2(y, x) * 180 / Math.PI; // -180..180, 0 = right
        ang = norm360(ang + 90); // convert so 0 = top (north)
        return ang;
      }
      compassWrap.addEventListener('mousedown', (e)=>{
        if(!state.manualMode) return;
        dragging = true;
        lastA = angleFromEvent(e);
        e.preventDefault();
      });
      window.addEventListener('mousemove', (e)=>{
        if(!dragging) return;
        const a = angleFromEvent(e);
        let d = shortestDelta(lastA, a);
        lastA = a;
        state.manualRotation = norm360((state.manualRotation || 0) + d);
        refreshUI();
      });
      window.addEventListener('mouseup', ()=>{ dragging = false; });
      // touch
      compassWrap.addEventListener('touchstart', (e)=>{
        if(!state.manualMode) return;
        dragging = true; lastA = angleFromEvent(e); e.preventDefault();
      }, {passive:false});
      window.addEventListener('touchmove', (e)=>{
        if(!dragging) return;
        const a = angleFromEvent(e);
        let d = shortestDelta(lastA, a);
        lastA = a;
        state.manualRotation = norm360((state.manualRotation || 0) + d);
        refreshUI();
      }, {passive:false});
      window.addEventListener('touchend', ()=>{ dragging = false; });
    }

    // ---------------- Buttons ----------------
    btnStart.addEventListener('click', ()=>{
      // start both GPS and compass (ask for permissions)
      startGeolocation();
      startCompass();
      if(!map) initMap();
    });

    btnCal.addEventListener('click', ()=>{
      alert('Cihaz pusulasını kalibre etmek için telefonu düz tutup 8 çizecek şekilde yavaşça döndürün. Metal ve manyetik alanlardan uzak durun.');
    });

    btnMode.addEventListener('click', ()=>{
      state.manualMode = !state.manualMode;
      btnMode.textContent = state.manualMode ? 'Manuel: Açık' : 'Manuel: Kapalı';
      if(state.manualMode){
        // when entering manual mode, set manualRotation to current heading
        state.manualRotation = state.heading || 0;
      }
      refreshUI();
    });

    btnVoiceToggle.addEventListener('click', ()=>{
      state.voiceOn = !state.voiceOn;
      btnVoiceToggle.textContent = 'Sesli: ' + (state.voiceOn ? 'Açık' : 'Kapalı');
      if(!state.voiceOn && synth && synth.speaking) synth.cancel();
    });

    btnCopy.addEventListener('click', async ()=>{
      if(!state.pos) { alert('Konumunuz alınamadı.'); return; }
      try {
        await navigator.clipboard.writeText(`${state.pos.lat.toFixed(6)}, ${state.pos.lon.toFixed(6)}`);
        alert('Koordinat kopyalandı: ' + `${state.pos.lat.toFixed(6)}, ${state.pos.lon.toFixed(6)}`);
      } catch (e){
        alert('Kopyalama hatası: ' + e.message);
      }
    });

    btnStop.addEventListener('click', ()=>{
      if(state.watchId) { navigator.geolocation.clearWatch(state.watchId); state.watchId = null; }
      state.heading = null; state.headingRaw = null; state.pos = null; state.qibla = null; state.distance = null; state.acc = null;
      if(synth && synth.speaking) synth.cancel();
      refreshUI();
    });

    // ---------------- Voice & TTS init ----------------
    // Try populate voices, may be async
    window.speechSynthesis.onvoiceschanged = function(){
      // no action needed, voices will be used when speak() called
    };

    // Try to get default voice (prepare)
    function getTTSVoice(){
      const vs = speechSynthesis.getVoices();
      if(!vs || vs.length === 0) return null;
      // preference: Turkish
      const tr = vs.find(v=>/tr-?TR|turk/i.test(v.lang) || /turk/i.test(v.name));
      if(tr) return tr;
      // fallback to native language US/EN
      const en = vs.find(v=>/en-?US|en-/i.test(v.lang));
      return en || vs[0];
    }

    // ---------------- Initialization ----------------
    drawDial();           // draw ticks & labels
    initMap();            // init map early (ok if fail)
    enableManualDrag();   // allow manual dragging when toggled

    // Small demo: if no sensors, app still shows UI and map line
    refreshUI();

    // End IIFE
  })();
  </script>
</body>
</html>
